import { useEffect, useMemo, useRef, useState } from "react";
import { parse } from "./utils/fhirpath";
import { Model } from "fhirpath";
import { detectValueType } from "./utils/value";
import {
  Context,
  DeepPartial,
  ExternalBinding,
  FhirRegistry,
  FhirSchema,
  FhirValue,
  IProgram,
} from "./types/internal";
import Program from "./components/Program";
import { ProgramProvider } from "./components/ProgramProvider";
import { generateBindingId } from "./utils/expression";
import { Style, StyleProvider } from "./style";
import { Text, TextProvider } from "./text";

export interface IEditorProps {
  value?: string;
  defaultValue?: string;
  onChange?: (value: string) => void;
  data: any;
  variables?: Record<string, any>;
  schema: FhirSchema[];
  model: Model;
  debug?: boolean;
  portalRoot?: string;
  style?: DeepPartial<Style>;
  text?: DeepPartial<Text>;
}

function Editor({
  value,
  defaultValue,
  onChange,
  data,
  variables,
  schema,
  model,
  debug,
  portalRoot,
  style,
  text,
}: IEditorProps) {
  const isControlled = value !== undefined;
  const isControlledRef = useRef(isControlled);
  const lastGeneratedValueRef = useRef<string | undefined>(undefined);

  // Warn when both defaultValue and value are provided
  useEffect(() => {
    if (isControlled && defaultValue !== undefined) {
      console.warn(
        "FHIRPath Editor: You provided both value and defaultValue props. " +
          "The defaultValue prop will be ignored in controlled mode.",
      );
    }
  }, []);

  const [program, setProgram] = useState<IProgram>(() =>
    parse(isControlled ? value : defaultValue || ""),
  );

  // Update program when value changes in controlled mode,
  // but only if it wasn't generated by the component itself
  useEffect(() => {
    if (isControlled && value !== lastGeneratedValueRef.current) {
      setProgram(parse(value));
    }
  }, [value, isControlled]);

  // Warn if mode changes during lifetime
  useEffect(() => {
    if (isControlledRef.current !== isControlled) {
      console.warn(
        "FHIRPath Editor: Changing from " +
          (isControlledRef.current ? "controlled" : "uncontrolled") +
          " to " +
          (isControlled ? "controlled" : "uncontrolled") +
          " mode is not supported and may lead to unexpected behavior.",
      );
      isControlledRef.current = isControlled;
    }
  }, [isControlled]);

  const handleFhirPathChange = (newValue: string) => {
    if (onChange) {
      // Store the value we're about to emit to avoid unnecessary re-parsing
      lastGeneratedValueRef.current = newValue;
      onChange(newValue);
    }
  };

  const externalBindings = useMemo((): ExternalBinding[] => {
    return Object.entries(variables || {}).map(([name, value]) => ({
      id: generateBindingId(),
      name,
      type: detectValueType(value),
      value: new FhirValue(value),
    }));
  }, [variables]);

  const fhirSchema = useMemo(() => {
    const result: FhirRegistry = {};
    schema.forEach((entry) => {
      if (entry.id) result[entry.id] = entry;
      if (entry.url) result[entry.url] = entry;
    });
    return result;
  }, [schema]);

  const context = useMemo((): Context => {
    return {
      type: detectValueType(data),
      value: new FhirValue(data),
    };
  }, [data]);

  return (
    <StyleProvider style={style}>
      <TextProvider text={text}>
        <ProgramProvider
          program={program}
          onProgramChange={setProgram}
          onFhirPathChange={handleFhirPathChange}
          context={context}
          externalBindings={externalBindings}
          fhirSchema={fhirSchema}
          model={model}
          debug={!!debug}
          portalRoot={portalRoot}
        >
          <Program />
        </ProgramProvider>
      </TextProvider>
    </StyleProvider>
  );
}

export default Editor;
