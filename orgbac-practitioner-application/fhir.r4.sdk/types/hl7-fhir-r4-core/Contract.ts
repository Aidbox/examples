// WARNING: This file is autogenerated by FHIR Schema Codegen.
// https://github.com/fhir-schema/fhir-schema-codegen
// Any manual changes made to this file may be overwritten.

import { Annotation } from './Annotation';
import { Attachment } from './Attachment';
import { BackboneElement } from './BackboneElement';
import { CodeableConcept } from './CodeableConcept';
import { Coding } from './Coding';
import { DomainResource } from './DomainResource';
import { Identifier } from './Identifier';
import { Money } from './Money';
import { Period } from './Period';
import { Quantity } from './Quantity';
import { Reference } from './Reference';
import { Signature } from './Signature';
import { Timing } from './Timing';


export interface ContractContentDefinition extends BackboneElement {
    copyright?: string;
    publicationDate?: string;
    publicationStatus: 'amended' | 'appended' | 'cancelled' | 'disputed' | 'entered-in-error' | 'executable' | 'executed' | 'negotiable' | 'offered' | 'policy' | 'rejected' | 'renewed' | 'revoked' | 'resolved' | 'terminated';
    publisher?: Reference<'Organization' | 'Practitioner' | 'PractitionerRole'>;
    subType?: CodeableConcept;
    type: CodeableConcept;
}

export interface ContractFriendly extends BackboneElement {
    contentAttachment?: Attachment;
    contentReference?: Reference<'Composition' | 'DocumentReference' | 'QuestionnaireResponse'>;
}

export interface ContractLegal extends BackboneElement {
    contentAttachment?: Attachment;
    contentReference?: Reference<'Composition' | 'DocumentReference' | 'QuestionnaireResponse'>;
}

export interface ContractRule extends BackboneElement {
    contentAttachment?: Attachment;
    contentReference?: Reference<'DocumentReference'>;
}

export interface ContractSigner extends BackboneElement {
    party: Reference<'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>;
    signature: Signature[];
    type: Coding;
}

export interface ContractTerm extends BackboneElement {
    action?: ContractTermAction[];
    applies?: Period;
    asset?: ContractTermAsset[];
    group?: ContractTerm[];
    identifier?: Identifier;
    issued?: string;
    offer: ContractTermOffer;
    securityLabel?: ContractTermSecurityLabel[];
    subType?: CodeableConcept;
    text?: string;
    topicCodeableConcept?: CodeableConcept;
    topicReference?: Reference<'Resource'>;
    type?: CodeableConcept;
}

export interface ContractTermAction extends BackboneElement {
    context?: Reference<'Encounter' | 'EpisodeOfCare'>;
    contextLinkId?: string[];
    doNotPerform?: boolean;
    intent: CodeableConcept;
    linkId?: string[];
    note?: Annotation[];
    occurrenceDateTime?: string;
    occurrencePeriod?: Period;
    occurrenceTiming?: Timing;
    performer?: Reference<'CareTeam' | 'Device' | 'Location' | 'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson' | 'Substance'>;
    performerLinkId?: string[];
    performerRole?: CodeableConcept;
    performerType?: CodeableConcept[];
    reason?: string[];
    reasonCode?: CodeableConcept[];
    reasonLinkId?: string[];
    reasonReference?: Reference<'Condition' | 'DiagnosticReport' | 'DocumentReference' | 'Observation' | 'Questionnaire' | 'QuestionnaireResponse'>[];
    requester?: Reference<'Device' | 'Group' | 'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>[];
    requesterLinkId?: string[];
    securityLabelNumber?: number[];
    status: CodeableConcept;
    subject?: ContractTermActionSubject[];
    type: CodeableConcept;
}

export interface ContractTermActionSubject extends BackboneElement {
    reference: Reference<'Device' | 'Group' | 'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>[];
    role?: CodeableConcept;
}

export interface ContractTermAsset extends BackboneElement {
    answer?: ContractTermOfferAnswer[];
    condition?: string;
    context?: ContractTermAssetContext[];
    linkId?: string[];
    period?: Period[];
    periodType?: CodeableConcept[];
    relationship?: Coding;
    scope?: CodeableConcept;
    securityLabelNumber?: number[];
    subtype?: CodeableConcept[];
    text?: string;
    type?: CodeableConcept[];
    typeReference?: Reference<'Resource'>[];
    usePeriod?: Period[];
    valuedItem?: ContractTermAssetValuedItem[];
}

export interface ContractTermAssetContext extends BackboneElement {
    code?: CodeableConcept[];
    reference?: Reference<'Resource'>;
    text?: string;
}

export interface ContractTermAssetValuedItem extends BackboneElement {
    effectiveTime?: string;
    entityCodeableConcept?: CodeableConcept;
    entityReference?: Reference<'Resource'>;
    factor?: number;
    identifier?: Identifier;
    linkId?: string[];
    net?: Money;
    payment?: string;
    paymentDate?: string;
    points?: number;
    quantity?: Quantity;
    recipient?: Reference<'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>;
    responsible?: Reference<'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>;
    securityLabelNumber?: number[];
    unitPrice?: Money;
}

export interface ContractTermOffer extends BackboneElement {
    answer?: ContractTermOfferAnswer[];
    decision?: CodeableConcept;
    decisionMode?: CodeableConcept[];
    identifier?: Identifier[];
    linkId?: string[];
    party?: ContractTermOfferParty[];
    securityLabelNumber?: number[];
    text?: string;
    topic?: Reference<'Resource'>;
    type?: CodeableConcept;
}

export interface ContractTermOfferAnswer extends BackboneElement {
    valueAttachment?: Attachment;
    valueBoolean?: boolean;
    valueCoding?: Coding;
    valueDate?: string;
    valueDateTime?: string;
    valueDecimal?: number;
    valueInteger?: number;
    valueQuantity?: Quantity;
    valueReference?: Reference<'Resource'>;
    valueString?: string;
    valueTime?: string;
    valueUri?: string;
}

export interface ContractTermOfferParty extends BackboneElement {
    reference: Reference<'Device' | 'Group' | 'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole' | 'RelatedPerson'>[];
    role: CodeableConcept;
}

export interface ContractTermSecurityLabel extends BackboneElement {
    category?: Coding[];
    classification: Coding;
    control?: Coding[];
    number?: number[];
}

export interface Contract extends DomainResource {
    alias?: string[];
    _alias?: Element;
    applies?: Period;
    author?: Reference<'Organization' | 'Patient' | 'Practitioner' | 'PractitionerRole'>;
    authority?: Reference<'Organization'>[];
    contentDefinition?: ContractContentDefinition;
    contentDerivative?: CodeableConcept;
    domain?: Reference<'Location'>[];
    expirationType?: CodeableConcept;
    friendly?: ContractFriendly[];
    identifier?: Identifier[];
    instantiatesCanonical?: Reference<'Contract'>;
    instantiatesUri?: string;
    _instantiatesUri?: Element;
    issued?: string;
    _issued?: Element;
    legal?: ContractLegal[];
    legallyBindingAttachment?: Attachment;
    legallyBindingReference?: Reference<'Composition' | 'Contract' | 'DocumentReference' | 'QuestionnaireResponse'>;
    legalState?: CodeableConcept;
    name?: string;
    _name?: Element;
    relevantHistory?: Reference<'Provenance'>[];
    rule?: ContractRule[];
    scope?: CodeableConcept;
    signer?: ContractSigner[];
    site?: Reference<'Location'>[];
    status?: 'amended' | 'appended' | 'cancelled' | 'disputed' | 'entered-in-error' | 'executable' | 'executed' | 'negotiable' | 'offered' | 'policy' | 'rejected' | 'renewed' | 'revoked' | 'resolved' | 'terminated';
    _status?: Element;
    subject?: Reference<'Resource'>[];
    subtitle?: string;
    _subtitle?: Element;
    subType?: CodeableConcept[];
    supportingInfo?: Reference<'Resource'>[];
    term?: ContractTerm[];
    title?: string;
    _title?: Element;
    topicCodeableConcept?: CodeableConcept;
    topicReference?: Reference<'Resource'>;
    type?: CodeableConcept;
    url?: string;
    _url?: Element;
    version?: string;
    _version?: Element;
}

